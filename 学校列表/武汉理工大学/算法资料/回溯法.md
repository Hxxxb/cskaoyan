# 搜索

## 总方针

### BFS 宽度优先搜索总结

* 状态。需要确定所求解问题中的状态。通过状态的扩展，遍历所有的状态，从中寻找需要的答案
* 状态扩展方式：在宽度优先搜索中，需要尽可能地扩展状态，并对先扩展得到的状态先进行下一次状态扩展
* 有效状态。对有些状态，并不需要再次扩展它，而是直接舍弃他。因为根据问题的分析可知，目标状态不可能 由这些状态经过若干次扩展得到，所以直接舍弃
* ==**队列**==。为了使得先得出的状态能够优先扩展，于是使用队列，将得到的状态依次放入队尾，==每次取队头元素==进行扩展
* 标记。为了判断哪些状态是有效的，哪些是无效的，往往使用标记。
* 有效状态数。问题中的有效状态数与算法的时间复杂度同量级，所以在进行搜索之前，必须估算其是否在能够接受的范围内
* 最优。宽度优先搜索常被用来求解最优值问题，因为其搜索到的状态总是按照某个关键字递增，这个特性非常适合求解最优值问题。

```c++
int BFS(int n,int k){
    queue<Status> Sq;//新建一个队列用来存储所有可能经过的位置
    Sq.push(Status(n,0));//压入初始状态
    visit[n] = true;//当前位置n已经被访问过了
    while (!Sq.empty()) {//队列中还有元素的时候不断弹出
        Status cur = Sq.front();//cur为队头元素
        Sq.pop();
        if (cur.x == k ) {//如果队头元素恰好走到路径就返回
            return cur.t;
        }
        for (int i = 0; i <= 2; ++i) {//分别对三种可能的走法进行分析，如果没走到终点就都进入队列
            Status next(cur.x,cur.t + 1);//next为下一点的位置以及时间
            if (i == 0) {
                next.x++;//加1
            }
            if (i == 1) {
                next.x--;//减1
            }
            if (i == 2) {
                next.x*=2;//乘2
            }
            if (next.x > MAXN || next.x < 0 || visit[next.x]) {
                continue;//位置超出范围（过小，过大，访问过）
            }
            Sq.push(next);//新位置进入队列
            visit[next.x] = true;//标记访问过位置next
        }
    }
    return 0;
}
```

### DFS 深度优先搜索总结 + 回溯法

**具有限界函数的深度优先生成法称为回溯法**

总体分为子集树和排列树

* 当我们要解决的问题是要求一个使问题最优的 n 个元素的子集，问题的解空间常可以组织成一棵子集树

* 当所给的问题是从n个元素的集合S中找出满足某种性质的子集时，相应的解空间树成为子集树。

* 构造所有的子集

  * n 个元素的集合有多少个子集? 
  * 如果每个 S~i~ 的大小是 k，对每个 x~i~∈S~i~，共有 k^n^ 个子集
  * 子集树：

  ```c++
  void Backtrack(int t) {     //t 表示当前是树的第t层，即对集合 S 中的第 t 个元素进行判断
      if (t > n)
          output(x);          //大于S中总的元素个数 ，遍历完成 
      else
          for (int i = 0; i < = l; i++) { // 两种可能 加入或者不加入到解集合,l是总的方向总数
              x[t] = i;
              if (Constraint(t) && Bound(t)){     //满足约束条件  
                      Backtrack(t + 1);           //对 t+1 层进行判断 
                  } 
          }
  }
  ```

* 排列树：当所给的问题是确定n个元素满足某种性质的排列时，相应的解空间树称为排列树。排列树通常有n!个叶节点。

  ```cpp
  void Backtrack(int t) {     //t 表示集合 S 的第 t 个元素 
      if (t > n)
          output(x);
      else
          for (int i = t; i <= n; i++) {      //第t 个元素与其后面的所有元素进行交换位置 
              swap(x[t], x[i]);
              if (constraint(t) && bound(t)){ 
                      backtrack(t + 1);
                  } 
              swap(x[t], x[i]);
          }
  }
  ```
#### 剪枝函数
• 剪枝函数一般有两种：约束函数和限界函数
• 利用剪枝函数，剪除无效的分支,集中搜索最有用的分支. • 为了改进搜索，应用回溯法至少需要注意以下四点：
① 怎样选择约束函数。
② 怎样计算上界 (对最大化问题) 
③ 怎样计算下界 (对最小化问题)
④ 怎样利用约束函数和限界函数来进行剪枝.
• 通常，对极大值问题，我们对扩展节点 i计算上界 B(i)。如果目前保存的最大目标值不比 B(i)大，那么进行剪枝，否则继续。

![image-20200329155111664](https://gitee.com/yangshucheng2020/blogimage/raw/master/uPic/image-20200329155111664.png)

• 通常，对极小值问题，我们对扩展节点 i计算上界 B(i)。如果目前保存的最大目标值不比 B(i)小，那么进行剪枝，否则继续。

![image-20200329155213174](https://gitee.com/yangshucheng2020/blogimage/raw/master/uPic/image-20200329155213174.png)



#### 寻找出最优解：void Backtrack(...){}

作业调度问题：排列树

```cpp
void Backtrace(int k){
    int temp;
    if (k > n) {//到达叶子结点，达到最底部
        if (curtime < lowest) {
            lowest = curtime;//保存调度最短时间
            for (int i = 1; i <= n; ++i) {
                visit[i] = x[i];//存储当前调度作业顺序
            }
        }
        return;
    }
    else{//非叶子结点，需要全排列，从k位置开始
        for (int j = k; j <= n; ++j) {
//只算作业在机器1的总处理时间，相当于机器1从开始一直运行到作业j用完机器1所消耗的时间
            f1 += cost[x[j]][1];
            temp = f2;//temp存储上一个作业在机器2的完成处理时间
//观察在机器1运行完的时间更长还是完成上一个作业（f2）的时间更长
//更长的那个时间 + 机器2处理的时间 = 作业j按当前调度的完成时间
            f2 = (f1 > f2 ? f1 : f2) + cost[x[j]][2];//f2为当前作业完成时间
            curtime += f2;//算出调度到作业j的完成时间和 = 每个作业完成时间之和
            if (curtime < lowest) {//如果当前的完成时间小于之前的最少处理时间，则继续搜索
                swap(x[j], x[k]);//交换两个作业序号的位置
                Backtrace(k + 1);
                swap(x[j], x[k]);//交换回来准备回溯
            }//回溯，将值复原到进入这个循环结构之前
            curtime -= f2;
            f2 = temp;
            f1 -= cost[x[j]][1];
        }
    }
    return;
}
```

#### 是否有解：bool Backtrack(...){}

马踏棋盘：子集树

```cpp
bool Backtrack(int x,int y,int step,string ans){
    if (step == p * q) {//搜索成功
        cout << ans << endl << endl;
        return true;
    }else{
        for (int i = 0; i < 8; ++i) {//遍历邻居节点
            int nx = x + derection[i][0];//扩展状态坐标
            int ny = y + derection[i][1];
            if (nx < 0 || nx >= p || ny < 0 || ny >= q || visit[nx][ny] ) {
                continue;//nx是新的行，不超过p行，ny是新的列，不超过p列
            }
            char col = ny + 'A';//列标记
            char row = nx + '1';//行标记
            visit[nx][ny] = true;//新位置符合条件，则标记到达过
            if(Backtrack(nx, ny, step + 1, ans + col + row)){//成功则返回真
                return true;
            }
            visit[nx][ny] = false;//取消标记，回溯
        }
    }
    return false;
}
```

## 所有符号匹配

括号。设计一种算法，打印n对括号的所有合法的（例如，开闭一一对应）组合。

说明：解集不能包含重复的子集。

例如，给出 n = 3，生成结果为：

```cpp
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```

```cpp
class Solution {
public:
    void dfs(int left,int right,string temp,int n,vector<string>& res){
        if(temp.size() == 2 * n){
            res.push_back(temp);
            return;
        }
        if(left < n){
            dfs(left + 1,right,temp + "(",n,res);
        }
        if(right < left){
            dfs(left,right + 1,temp + ")",n,res);
        }
    }
    vector<string> generateParenthesis(int n) {
        vector<string> res;
        string temp = "(";
        dfs(1,0,temp,n,res);
        return res;
    }
};
```





## 循环赛制

这种解法是把求解 2^k^ 个选手的比赛日程问题划分为 2^1^ , 2^2^ ，......，2^k^  个选手的比赛日程问题。也就是说，要求 2^k^个选手的比赛日程，就要分为两部分，分别求出 2^(k-1)^ 个选手的比赛日程，然后再进行合并。当然，这种解法只能求选手个数是2的次幂的情况。

在每次迭代求解的过程中，可以看作4部分：

1）求左上角子表：左上角子表是前 2^(k-1)^ 个选手的比赛前半程的比赛日程。

2）求左下角子表：左下角子表是剩余的 2^(k-1)^ 个选手的比赛前半程比赛日程。这个子表和左上角子表的对应关系

式，对应元素等于左上角子表对应元素加 2^(k-1)^ 。

3）求右上角子表：等于左下角子表的对应元素。

4）求右下角子表：等于左上角子表的对应元素。

```c++
#include<iostream>
#include<vector>
using namespace std;
void GameTable(vector<vector<int> > &vec){
    if(vec.size() == 0){//如果向量数组大小为0，返回
        return;
    }//s为vec的行大小
    size_t s = vec.size();
    int k = 0;
    while(s = s >> 1){
        //计算出2^k 中的k的大小
        k++;
        }
    //初始化
    vec[0][0] = 1;
    vec[0][1] = 2;
    vec[1][0] = 2;
    vec[1][1] = 1;
    for(int i = 2; i <= k; i++){
        int length = 0x1 << i;//length = 2^i,当前填写表格的长度
        int half = length >> 1;//half = 2^(i-1)，长度的一半
        //左下角的子表中项为左上角子表对应项加half=2^(i-1)
        for(int row = 0; row < half; row++){
            for(int col = 0; col < half; col++){
                vec[row + half][col] = vec[row][col] + half;
            }
        }
        //右上角的子表 = 左下角子表
        for(int row = 0; row < half; row++){
            for(int col = 0; col < half; col++){
                vec[row][col + half] = vec[row + half][col];
            }
        }
        //右下角的子表 = 左上角子表
        for(int row = 0; row < half; row++){
            for(int col = 0; col < half; col++){
                vec[row + half][col + half] = vec[row][col];
            }
        }
    }
}
int main(void){
    cout << "共有2^k个选手参加比赛，输入k（k>0）：" << endl;
    int k;
    do{
        cin >> k;
    }while(k < 0 || k > 31);
    int s = 0x1 << k;
    vector<vector<int> > vec(s, vector<int>(s, 0));
    cout << vec.size() << endl;
    //一个二维int类型s*s个元素向量数组，且值均为0的vector容器vec
    GameTable(vec);
    for(size_t i = 0; i < vec.size(); i++){
        for(size_t j = 0; j < vec[i].size(); j++){
            cout << vec[i][j] << " ";
        }
        cout << endl;
    }
    return 0;
}
```

## 装载问题

 *每组测试数据：第1行有2个整数c和n。C是轮船的载重量（0＜c＜30000），n是集装箱的个数（n≤20）。第2行有n个整数w1, w2, …, wn，分别表示n个集装箱的重量。*

 *输出*

 *对每个测试例，输出两行：第1行是装载到轮船的最大载重量，第2行是集装箱的编号。*

 *输入样例*

 *34 3*

 *21 10 5*

 *输出（考虑最大装载量的最优解）*

 *31（重量）*

 *1 2*

 *考虑最大装载件数的最优解*

 *2（件）*

 *5 10*

### 简单回溯法

扫描当前w[k]箱子的重量，如果能放则放，接着递归，其他情况都是不放（包含放不下去和故意不放的情况）

```c++
#include<iostream>
#include<vector>
using namespace std;
const int MAXN = 1000;
int w[MAXN];
int C,n,bestw = 0;
void Contain(int k,int currentw){//选择第k件物品，当前最大值为MAX,可容纳最大总重量为weight
    if (k >= n) {
        if (bestw < currentw ) {
            bestw = currentw;
        }
        return;
    }
    if (w[k] + currentw <= C)//不超重，可以选择第k个物品
        Contain(k + 1,currentw + w[k]);
    Contain(k + 1, currentw);//不选择当前物品，直接扫描下一个物品
    return;
}
int main(){
    cout << "输入轮船载重量C,集装箱个数n,n个箱子的重量"<<endl;
    cin >> C >> n;
    for (int i = 0; i < n; ++i) {
        cin >> w[i];
    }
    Contain(0, 0);
    cout << bestw;
    return 0;
}
```

### 使用限界函数

改进的回溯算法
利用限界函数其中， ow表示剩余货箱的总重量
剪枝
若 w[k] + currentw + ow  <= bestw ，则停止搜索第 i 层及其下面的层，否则，继续搜索。其中，bestw 表示目前为止所得到的最佳重量

```c++
#include<iostream>
#include<vector>
using namespace std;
const int MAXN = 1000;
int w[MAXN];
int C,n,sum = 0,bestw = 0;
void Contain(int k,int currentw,int ow){
    //选择第k件物品，当前最大值为MAX,可容纳最大总重量为weight，剩余的货物质量为ow
    if (k >= n) {
        if (bestw < currentw ) {
            bestw = currentw;
        }
        return;
    }
    ow -= w[k];
    if (w[k] + currentw + ow <= bestw) {
        //选择全部剩下的物品时不超过最大值，则不需搜索
        return;
    }
    if (w[k] + currentw <= C)
        //不超重，则可以选择第k个物品
        Contain(k + 1,currentw + w[k],ow);
    Contain(k + 1, currentw,ow);//不选择当前物品，直接扫描下一个物品
    return;
}
int main(){
    cout << "输入轮船载重量C,集装箱个数n,n个箱子的重量"<<endl;
    cin >> C >> n;
    for (int i = 0; i < n; ++i) {
        cin >> w[i];
        sum += w[i];
    }
    Contain(0, 0,sum);
    cout << bestw;
    return 0;
}

```



## 地图着色问题

图的m-着色判定问题——给定无向连通图G和m种不同的颜色。用这些颜色为图G的各顶点着色，每个顶点着一种颜色，是否有一种着色法使G中任意相邻的2个顶点着不同颜色?

图的m-着色优化问题——若一个图最少需要m种颜色才能使图中任意相邻的2个顶点着不同颜色，则称这个数m为该图的色数。求一个图的最小色数m的问题称为m-着色优化问题。

回溯过程：

1. 填充该颜色

2. 判断是否合法，合法则继续填充下一个
3. 不合法则回溯：去掉颜色color[k] = 0，返回上一个点k--
4. 如果找到其中一种方法则输出

```c++
#include <cstdio>
#include <cstring>
int color[500];//存储填充颜色的具体方案，color[i]表示点i的颜色
bool ok(int k,int c[][100])
{//判断顶点k相连的边与它颜色是否相同
    for(int i = 1;i < k;i++)
    {
        if(c[k][i] == 1 && color[i] == color[k])
        //如果已经着色的k 与之相连的顶点和他同色，返回假
            return false;
    }
    return true;
}
int graphColor(int n,int m,int c[][100])
{
    int cnt=0;//统计填色方案种类数量
    memset(color,0,sizeof(color));//初始化
    int k=1;//从点k=1开始染色
    while(k>=1)
    {
        color[k]+=1;///染第一种颜色
        while(color[k] <= m)
        {//当还可以填充颜色的时候
            if(ok(k,c))
            //如果k位置的点可以填充这个颜色
                break;
            else
                color[k]++;//不可填充这个颜色，搜索下一个颜色
        }///挑选合适颜色
        if(color[k] <= m && k == n)
        { ///找完则输出
            for(int i=1;i<=n;i++)//输出点1到点n所填充的颜色
                printf("%d ",color[i]);
            printf("\n");
            cnt++;//计数加一
        }
        else if(color[k] <= m && k < n)
        {//没找完所有的点
            k++;///染下一个顶点
        }
        else
        {//颜色超出或者个数超出时，这个k点回溯上一个点k-1
            color[k]=0;///回溯,变为未填充状态找其他方法
            k--;//找上一个点
        }
    }
    return cnt;
}
int main()
{
    int n,m,i,j;
    int c[100][100];
    printf("输入顶点数n和着色数m:\n");
    scanf("%d %d",&n,&m);
    printf("输入无向图的邻接矩阵:\n");
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
            scanf("%d",&c[i][j]);
    printf("各个点所着颜色的所有解:\n");
    int cnt=graphColor(n,m,c);
    printf("方案数: %d\n",cnt);
}
///图着色问题回溯法
/**
 无向图邻接矩阵示例
 1 0 0 0
 1 0 1 0
 0 0 1 0
 0 0 1 0
 1 1 0 0
 */


```



## 马踏棋盘



![image-20200329104319769](https://gitee.com/yangshucheng2020/blogimage/raw/master/uPic/image-20200329104319769.png)

```cpp
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
using namespace std;
const int MAXN = 30;
int p,q;//p*q
bool visit[MAXN][MAXN];
int derection[8][2] = {//derection[-1][-2]表示x坐标-1，y坐标-2，x是行,y是列
    {-1,-2},{1,-2},{-2,-1},{2,-1},{-2,1},{2,1},{-1,2},{1,2}
};
bool Backtrack(int x,int y,int step,string ans){
    if (step == p * q) {//搜索成功
        cout << ans << endl << endl;
        return true;
    }else{
        for (int i = 0; i < 8; ++i) {//遍历邻居节点
            int nx = x + derection[i][0];//扩展状态坐标
            int ny = y + derection[i][1];
            if (nx < 0 || nx >= p || ny < 0 || ny >= q || visit[nx][ny] ) {
                continue;//nx是新的行，不超过p行，ny是新的列，不超过p列
            }
            char col = ny + 'A';//列标记
            char row = nx + '1';//行标记
            visit[nx][ny] = true;//新位置符合条件，则标记到达过
            if(Backtrack(nx, ny, step + 1, ans + col + row)){//成功则返回真
                return true;
            }
            visit[nx][ny] = false;//取消标记，回溯
        }
    }
    return false;
}
int main(){
    int n;
    scanf("%d",&n);
    int caseNumber = 0;
    while (n--) {
        scanf("%d%d",&p,&q);
        memset(visit, false, sizeof(visit));
        cout << "Scenario #" << ++caseNumber << ":"<< endl;
        visit[0][0] = true;//标记A1点
        if(!Backtrack(0,0,1,"A1")){//输入初始状态，如果不成功则输出不可能
            cout << "impossible" << endl << endl;
        }
    }
    return 0;
}

```

## 矩阵中的路径

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。

[["a","b","c","e"],
["s","f","c","s"],
["a","d","e","e"]]

但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。

示例 1：

>   输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
>   输出：true

示例 2：

>   输入：board = [["a","b"],["c","d"]], word = "abcd"
>   输出：false

```cpp
class Solution {
public:
    int direction[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};
    int row,col;
    bool dfs(vector<vector<char>>& board, vector<vector<bool>>& visit,
             int x,int y,int idx,string word){
        if(board[x][y] != word[idx]) return false;
        visit[x][y] = true;
        idx++;
        for(int i = 0;i < 4;++i){
            int nx = x + direction[i][0];
            int ny = y + direction[i][1];
            if(nx < 0 || nx >= row|| ny < 0 || ny >= col || visit[nx][ny]){
                continue;
            }
            if(dfs(board,visit,nx,ny,idx,word)){
                return true;
            }
        }
        visit[x][y] = false;
        if(idx == word.size()){
            return true;
        }
        return false;
    }
    bool exist(vector<vector<char>>& board, string word) {
        if(word == "")  return false;
        row = board.size();
        col = board[0].size();
        vector<vector<bool>> visit(row ,vector<bool>(col,false));
        for(int i = 0;i < row;++i){
            for(int j = 0;j < col;++j){
                if(board[i][j] == word[0]){
                    if(dfs(board,visit,i,j,0,word)){
                        return true;
                    }
                }
            }
        }
        return false;
    }
};
```



初始化二维vector，为r*c的vector，所有值为0.

1.直接用初始化方法（递归的 vector<int>(c, 0)）

```cpp
 vector<vector<int> > newOne(r, vector<int>(c, 0));
```

2.用resize()来控制大小

```cpp
vector<vector<int> > res;
    res.resize(r);//r行
    for (int k = 0; k < r; ++k){
        res[k].resize(c);//每行为c列
    }
```

## 机器人的运动范围

地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

示例 1：

>   输入：m = 2, n = 3, k = 1
>   输出：3

示例 1：

>   输入：m = 3, n = 1, k = 0
>   输出：1

提示：

    1 <= n,m <= 100
    0 <= k <= 20

```cpp
class Solution {
public:
    int direction[4][2] = {
    {0,1},{0,-1},{1,0},{-1,0}
};
int rows,cols,countT = 0;
bool visit[105][105] = {false};
void DFS(int x,int y,int k){
    int cx = x,cy = y;
    int sum = 0;
    //sum = x / 10 + x % 10 + y / 10  + y % 10;
    do{
        sum = sum + (cx % 10);
        sum = sum + (cy % 10);
        cx /= 10;
        cy /= 10;
    }while (cx  > 0 || cy > 0);//cx，cy之前已经除以10了，确定好判断的条件
    if(x < 0 || y < 0 || x >= rows || y >= cols || sum > k || visit[x][y]) {
        return;
    }else{
        visit[x][y] = true;
        countT++;
        for(int i = 0;i < 4;++i){
            int nx = x + direction[i][0];
            int ny = y + direction[i][1];
            DFS(nx,ny,k);
        }
    }
    return;
}
int movingCount(int m, int n, int k) {
    rows = m;
    cols = n;
    if (k == 0) {
        return 1;
    }
    DFS(0,0,k);
    return countT;
}
};
```

## 礼物的最大值

在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？

 

示例 1:

>   输入: 
>   [
>     [1,3,1],
>     [1,5,1],
>     [4,2,1]
>   ]
>
>   输出: 12
>   解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物

 

提示：

```cpp
0 < grid.length <= 200
0 < grid[0].length <= 200
```

回溯算法（超时错误）：

```cpp
class Solution {
public:
    int maxsum = 0;
    bool visit[205][205] = {false};
    int rows,cols;
    int direction[2][2] = {
        {0,1},{1,0}
    };
    void dfs(vector<vector<int>>& grid,int x,int y,int sum){
        if(x < 0 || y < 0 || x >= rows || y >= cols ){
            if(maxsum < sum){
                maxsum = sum;
            }
            return;
        }else{
            for(int i = 0;i < 2;++i){
                int nx = x + direction[i][0];
                int ny = y + direction[i][1];
                visit[x][y] = true;
                dfs(grid,nx,ny,sum + grid[x][y]);
                visit[x][y] = false;
            }
            return;
        }
    };
    int maxValue(vector<vector<int>>& grid) {
        rows = grid.size();
        cols = grid[0].size();
        dfs(grid,0,0,0);
        return maxsum;
    };
};
```

改用动态规划：

思路：

状态表示：dp\[i\]\[j]表示到达i,j位置处的最大价值
转移方程：dp\[i\]\[j\] = max{dp\[i-1\]\[j],dp\[i][j-1]} + grid\[i][j];
dp数组初始状态：dp\[0\]\[j\] = {0}, dp\[i\]\[0\]= {0} （就是将第一行和第一列全部设为0）

其实这里的dp数组我们可以将它优化成一维的，优化之后的一维dp保存的是当前上一行的最大价值，然后我们从做到有去更新这个数组即可

```cpp
class Solution {
public:
    int maxValue(vector<vector<int>>& grid) {
        int rows = grid.size();
        int cols = grid[0].size();
        vector<int> dp(cols + 1,0);
        for(int i = 0;i < rows;++i){
            for(int j = 0;j < cols;++j){
                dp[j + 1] = max(dp[j],dp[j + 1]) + grid[i][j];//从dp[j+1]开始
                //到达每行最后一个元素的最大值,dp[j]表示前一个元素最大和，
                //dp[j+1]表示当前元素位置上一行元素的最大和  
            }
        }
        return dp[cols];
    };
};
```

## 二叉树中和为某一值的路径

输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。

示例:
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1

返回:

>   [
>      [5,4,11,2],
>      [5,8,4,5]
>   ]
>
>    
>

提示：

    节点总数 <= 10000

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
//收到数据再处理
//dfs(TreeNode* root,vector<int> cur,int now,int sum)表示：
//扫描到root结点时，之前的路径存储在cur中，之前的路径和为now，最终要达到的和为sum
class Solution {
public:
    vector<vector<int>> result;
    void dfs(TreeNode* root,vector<int> cur,int now,int sum){
        if(root == NULL) return;//如果当前扫描到空节点则返回
        cur.push_back(root->val);//当前结点非空，先把当前结点的值存储在cur中
        now = now + root->val;//计算包括当前结点时的路径和
        if(now == sum && root->left == NULL && root->right == NULL){
            result.push_back(cur);//刚好在叶子几点处满足路径和的条件
            return;
        }
        else{//还可以走其他路径的时候
            if(root->left){
                dfs(root->left,cur,now,sum);
            }
            if(root->right){
                dfs(root->right,cur,now,sum);
            }
            cur.pop_back();
        }
        return;
    }
    vector<vector<int>> pathSum(TreeNode* root, int sum) {
        vector<int> cur;
        dfs(root,cur,0,sum);
        return result;
    }
};
```




## 放木棍组成正方形

Description

Given a set of sticks of various lengths, is it possible to join them end-to-end to form a square?

Input

The first line of input contains N, the number of test cases. Each test  case begins with an integer 4 <= M <= 20, the number of sticks. M  integers follow; each gives the length of a stick - an integer between 1 and 10,000. 

Output

For each case, output a line containing "yes" if is is possible to form a square; otherwise output "no". 

Sample Input

```
3
4 1 1 1 1
5 10 20 30 40 50
8 1 7 2 6 4 4 3 5
```

Sample Output

```
yes
no
yes
```

思路：



```c++
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int MAXN = 25;
int stick[MAXN];
bool visit[MAXN];
int stickNum,sideLength;
bool compare(int a,int b){
    return a > b;
}
bool Backtrack(int sum,int number,int position){
    if (number == 3) {
        return true;
    }
    else{
        int sample = 0;
        for (int i = position; i < stickNum; ++i) {
            if (visit[i] == true || sum + stick[i] > sideLength || stick[i] == sample) {
                continue;//棍子被使用过 或者 选它会超过边长 或者 这根棍子无法构成当前边 则跳过
            }
            visit[i] = true;//标记访问过这根棍子
            if (sum + stick[i] == sideLength) {//如果选择了可以构成边长
                if (Backtrack(0, number + 1, 0)) {
                    return true;//能够构成所有边，则返回真
                }else{//如果这根棍子不能够组成正方形
                    sample = stick[i];//记录这根棍子
                }
            }else {//如果不能刚好构成边
                if(Backtrack(sum + stick[i], number, i + 1)){//选下一根棍子
                    return true;
                }else{//如果这根棍子不能够组成正方形
                    sample = stick[i];//记录这根棍子
                }
            }
            visit[i] = false;//这根棍子先别选，回溯标记数组，搜索下一根棍子
        }
    }
    return false;
}
int main(){
    int n;
    scanf("%d",&n);
    while (n--) {
        int sumAll = 0;
        cin >> stickNum;
        memset(stick, 0, sizeof(stick));
        memset(visit, false, sizeof(visit));
        for (int i = 0; i < stickNum; ++i) {
            cin >> stick[i];
            sumAll += stick[i];
        }
        sideLength = sumAll / 4;
        sort(stick, stick + stickNum, compare);
        if (sumAll % 4 != 0 || stick[0] > sideLength) {//剪枝：总长度不是4的倍数或者有超过边长的木棍
            cout << "no" <<endl;
            continue;
        }
        if(Backtrack(0, 0, 0)){
            cout <<"yes" << endl;
        }else{
            cout << "no" << endl;
        }
    }
    return 0;
}

```



## 算24

## 算式拼凑

### 1 2 3 4 5 6 7 8 9 = 110

### 无优先级运算

## 全排列

### 递归方法

```c++
#include <iostream>
#include <algorithm>
#include <string>
using namespace std;
const int MAXN = 20;
bool visit[MAXN];//存储字符的位置是否被访问
char sequence[MAXN];//存储字符的结果
void GetPermutation(string str ,int idx){
    if (idx >= str.size()) {
    //如果当前下标超出字符串大小则表示成功找到一个全排列
        cout << sequence << endl;
        return;
    }
    else{
        for (int i = 0; i < str.size(); ++i) {
            if (visit[i]) {
                continue;//如果当前字符已经被访问过，则跳过
            }
            visit[i] = true;//被访问了
            sequence[idx] = str[i];
            //将当前没有被访问过的字符加入字符数组idx所指向的位置
            GetPermutation(str, idx + 1);//确定下一个位置
            visit[i] = false;//回溯
        }
    }
    return;
}
int main()
{
    
    string str;
    while (cin >> str) {
        memset(visit, 0, sizeof(visit));
        sort(str.begin(), str.end());
        GetPermutation(str, 0);
    }
    
    return 0;
}
```

### 非递归方法

1.  从后往前寻找第一个逆序的坐标index
2.  将此坐标的字母与先前升序的坐标集合进行比较，寻找第一个比str[index]大的坐标，他们进行交换
3.  对交换后的排列，从index+1开始到最后进行翻转得到新的排列

```cpp
#include <iostream>
#include <algorithm>
#include <string>
using namespace std;
string str;
bool GetPermutation(){
    int n = str.size();
    int index = n - 1;
    while(index >= 1 && str[index] < str[index - 1]){
        index--;
    }//寻找拐点
    index--;//拐点坐标为index
    if (index < 0) {//已经为54321退出
        return false;
    }else{//进行交换、逆转操作
        for (int i = n - 1; i > index; i--) {
            if (str[index] < str[i]) {//从后往前扫描遇到第一个比str[index]大的则交换
                swap(str[index], str[i]);
                break;
            }
        }
        reverse(str.begin() + index + 1, str.end());
        return true;
    }
}
int main()
{
    while (cin >> str) {
        sort(str.begin(),str.end());
        do {
            cout << str << endl;
        } while (GetPermutation());
        cout << endl;
    }
    return 0;
}

```



### 系统函数方法

```c++
#include <iostream>
#include <algorithm>
#include <string>
using namespace std;
int main()
{
    
    string str;
    while (cin >> str) {
        sort(str.begin(), str.end());
        do {
            cout << str << endl;
        } while (next_permutation(str.begin(), str.end()));
    }
    return 0;
}
```

### 全排列去重复

输入一个字符串，打印出该字符串中字符的所有排列。

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

```cpp
class Solution {
public:
    vector<string> result;
    vector<string> permutation(string s) {
        dfs(s, 0);
        return result;
    }
    void dfs(string s, int pos) {
        if (pos >= s.size()) {
            result.push_back(s);
            return;
        }
        for (int i = pos; i < s.size(); ++i) {
            if (judge(s, pos, i)) continue;   
            // 如果pos和i之间有字符等于s[i]，则跳过，防止重复
            swap(s[pos], s[i]);
            dfs(s, pos+1);
            swap(s[pos], s[i]);
        }
    }
    bool judge(string& s, int start, int end) {
        for (int i = start; i < end; ++i) {
            if (s[i] == s[end]) return true;
        }
        return false;
    }
};
```



## 八皇后

## 迷宫

### 求完全迷宫路径的条数

在二维网格 grid 上，有 4 种类型的方格：

    1 表示起始方格。且只有一个起始方格。
    2 表示结束方格，且只有一个结束方格。
    0 表示我们可以走过的空方格。
    -1 表示我们无法跨越的障碍。

返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，每一个无障碍方格都要通过一次。

 

示例 1：

>   输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
>   输出：2
>   解释：我们有以下两条路径：
>   1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
>   2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
>

示例 2：

>   输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]
>   输出：4
>   解释：我们有以下四条路径： 
>   1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
>   2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
>   3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
>   4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)
>

示例 3：

>   输入：[[0,1],[2,0]]
>   输出：0
>   解释：
>   没有一条路能完全穿过每一个空的方格一次。
>   请注意，起始和结束方格可以位于网格中的任意位置。



```cpp
class Solution {
    public:
    int count = 0;
    int direction[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};
    void dfs(vector<vector<int>>& grid, int x, int y, int n){
        if(x<0 || x>=grid.size() || y<0 || y>=grid[x].size() || grid[x][y] == -1) return;
        if(grid[x][y]==2){
            if(n == 0){
                ++count;
            }
            return;
        }
        grid[x][y] = -1;
        for(int i = 0;i < 4;++i){
            int nx = x + direction[i][0];
            int ny = y + direction[i][1];
            dfs(grid,nx,ny,n-1);
        }
        grid[x][y] = 0;
        return;
    }
    int uniquePathsIII(vector<vector<int>>& grid) {
        int step = 1, x = 0, y = 0;
        for(int i=0; i<grid.size(); ++i)
            for(int j=0; j<grid[i].size(); ++j)
                if(grid[i][j]==1) x=i, y=j;
                else if(grid[i][j]==0) ++step;
        dfs(grid,x,y,step);
        return count;
    }
};

```

### 寻找迷宫最短路径

定义一个二维数组N*M（其中2<=N<=10;2<=M<=10），如5 × 5数组下所示： 

int maze[5][5] = {
    0, 1, 0, 0, 0,
    0, 1, 0, 1, 0,
    0, 0, 0, 0, 0,

​    0, 1, 1, 1, 0,
​    0, 0, 0, 1, 0,  
};
它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。入口点为[0,0],既第一空格是可以走的路。

Input

一个N × M的二维数组，表示一个迷宫。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。

Output

左上角到右下角的最短路径，格式如样例所示。

Sample Input

0 1 0 0 0

0 1 0 1 0

0 0 0 0 0

0 1 1 1 0

0 0 0 1 0

Sample Output

(0, 0)

(1, 0)

(2, 0)

(2, 1)

(2, 2)

(2, 3)

(2, 4)

(3, 4)

(4, 4)


```cpp
#include<iostream>
#include<vector>
using namespace std;
 
int N, M; //分别代表行和列
vector<vector<int>> maze;//迷宫矩阵
vector<vector<int>> path_temp;//存储当前路径，第一维表示位置
vector<vector<int>> path_best;//存储最佳路径
int direction[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};
void MazeTrack(int x, int y)
{
    maze[x][y] = 1;//表示当前节点已走，不可再走
    path_temp.push_back({ x, y });//将当前节点加入到路径中
    if (x == N - 1 && y == M - 1) //判断是否到达终点
        if (path_best.empty() || path_temp.size() < path_best.size())
            path_best = path_temp;
 	for(int i = 0; i < 4 ; ++i){
 		int nx = x + direction[i][0];
        int ny = y + direction[i][1]; 
        if(nx<0 || nx>=N || ny<0 || ny>=M || maze[nx][ny]){continue;}
        MazeTrack(nx, ny);
 	}
 	maze[x][y] = 0;         //恢复现场，设为未走
    path_temp.pop_back();
}
int main()
{
    while (cin >> N >> M)
    {
        maze = vector<vector<int>>(N, vector<int>(M, 0));
        path_temp.clear();
        path_best.clear();
        for (auto &i : maze)
            for (auto &j : i)
                cin >> j;
        MazeTrack(0, 0);//回溯寻找迷宫最短通路
        for (auto i : path_best)
            cout << '(' << i[0] << ',' << i[1] << ')' << endl;//输出通路
    }
    return 0;
}
```



## 八数码

## ROAD

## 作业调度问题

 给定n个作业的集合{J1,J2,…,Jn}。每个作业必须先由机器1处理，然后由机器2处理。作业Ji需(1≤i≤n)要机器j(1≤j≤2)的处理时间为tji。对于一个确定的作业调度，设F\[ j \] \[ i \]是作业i在机器j上完成处理的时间。所有作业在机器2上完成处理的时间和称为该作业调度的完成时间和。要求对于给定的n个作业，制定最佳作业调度方案，使其完成时间和达到最小。

|tji 	|机器1 |	机器2|
|--- |--- |
|作业1       |2 	|     1|
|作业2      |3 	|           1|
|作业3      |2 	 |          3|

例如，对于这张表格所示的情况，3个作业有3!=6种可能调度方案，很显然最坏复杂度即为O(n!)。如果按照2,3,1的顺序,则作业2的完成时间为4，作业3的完成时间为8，作业1的完成时间为9，完成时间和为21。最优的作业调度顺序为最佳调度方案是1,3,2，其完成时间和为18。

```c++
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXN = 100;
int n;//作业数量
int x[MAXN];//记录当前调度序号
int cost[MAXN][3];//cost[j][i]表示作业j在第i台机器上的处理时间
int lowest = 10000;//最小处理时间
int visit[MAXN];//调度作业顺序
int curtime = 0;//当前已完成的所有作业的完成时间和
int f1 = 0,f2 = 0;//f1为调度到作业j时，机器1上的纯处理时间之和
//f2为作业j的完成时间
void Backtrace(int k){
    int temp;
    if (k > n) {//到达叶子结点，达到最底部
        if (curtime < lowest) {
            lowest = curtime;//保存调度最短时间
            for (int i = 1; i <= n; ++i) {
                visit[i] = x[i];//存储当前调度作业顺序
            }
        }
        return;
    }
    else{//非叶子结点，需要全排列，从k位置开始
        for (int j = k; j <= n; ++j) {
//只算作业在机器1的总处理时间，相当于机器1从开始一直运行到作业j用完机器1所消耗的时间
            f1 += cost[x[j]][1];
            temp = f2;//temp存储上一个作业在机器2的完成处理时间
//观察在机器1运行完的时间更长还是完成上一个作业（f2）的时间更长
//更长的那个时间 + 机器2处理的时间 = 作业j按当前调度的完成时间
            f2 = (f1 > f2 ? f1 : f2) + cost[x[j]][2];//f2为当前作业完成时间
            curtime += f2;//算出调度到作业j的完成时间和 = 每个作业完成时间之和
            if (curtime < lowest) {//如果当前的完成时间小于之前的最少处理时间，则继续搜索
                swap(x[j], x[k]);//交换两个作业序号的位置
                Backtrace(k + 1);
                swap(x[j], x[k]);//交换回来准备回溯
            }//回溯，将值复原到进入这个循环结构之前
            curtime -= f2;
            f2 = temp;
            f1 -= cost[x[j]][1];
        }
    }
    return;
}
int main()
{
    cout << "请输入作业数量" << endl;
    cin >> n;
    cout << "请输入在各机器上的处理时间" << endl;
    for (int i = 1 ; i <= 2; ++i) {
        for (int j = 1; j <= n ; ++j) {
            cin >> cost[j][i];//输入作业j在及其i的耗时
        }
    }
    for (int i = 1; i <=n; ++i) {
        x[i] = i;
    }
    Backtrace(1);
    cout << "调度作业顺序" << endl;
    for (int i = 1; i <= n; ++i) {
        cout << visit[i] << " ";
    }
    cout << endl;
    cout << "处理时间" << endl << lowest;

    return 0;
}
/*
 请输入作业数量
 3
 请输入在各机器上的处理时间
 2 3 2
 1 1 3
 调度作业顺序
 1    3    2
 处理时间:
 18
 */

```

## 符号三角形

题目： 下面都是“-”。 下图是由14个“+”和14个“-”组成的符号三角形。2个同号下面都是“+”，2个异号下面都是“-”。 

```c++
+   +   -   +   -   +   +

   +   -   -   -   -   +

     -   +   +   +   -
   
       -   +   +   -
   
         -   +   -
   
           -   -
   
             +
```

在一般情况下，符号三角形的第一行有n个符号。符号三角形问题要求对于给定的n，计算有多少个不同的符号三角形，使其所含的“+”和“-”的个数相同。

思路：

1. 根据第一行的前t个字符来确定一个符号三角形

2. 通过前t个字符的符号三角形确定前t+1个字符的符号三角形

   ① 确定好第t+1个字符之后，在前面已经确定的符号三角形右边加一条边扩展而成

   ② 最终由前n个字符构成的符号三角形所确定的符号三角形包含的“+”个数与“-”的个数同为n(n+1)/4,因此在回溯的过程中用当前字符构成的符号三角形所确定的符号三角形中包含的“+”个数与“-”的个数均不超过n(n+1)/4作为可行性约束，用于减去不满足约束的子树。

   ③ 对于给定的n，当n(n+1)/2为奇数时，显然不包括“+”个数与“-”的个数相同的情况，输出错误信息

3. 变量说明：

   Backtrack(int k,int sum)

   函数作用：由前k-1个字符构成的符号三角形通过第k个字符来扩展符号三角形

   失败退出回溯条件：

   ​	① “+”个数（即sum的值）> n(n+1)/4;

   ​	② 或者 k*(k-1)/2 - sum > n(n+1)/4;

   成功退出回溯条件：

   ​	k > n时：当前已找到的符号三角形个数ans + 1

   k <= n 时：

   当前扩展结点Z是解空间的内部结点，有s\[1][t] = 1 和 s\[1][t] = 0 共2个儿子结点

   对当前扩展结点Z的每个儿子结点，计算其相应的符号三角形中“+”个数sum


```c++
#include <iostream>
#include <iomanip>
using namespace std;
const int MAXN = 100;
int ans = 0,half,n;
int s[MAXN][MAXN];
void Backtrack(int k,int sum){//t为第一行的第t个字符，sum为当前扫描的符号“+”比"-"多的个数
    if (sum > half || k * (k - 1) / 2 - sum > half ) {
        //当前填充字符中
        //“+”号元素大于n * (n + 1) / 4
        //或者 “-”号元素大于n * (n + 1) / 4
        return;//已经算出的子树不满足，剪枝
    }
    if (k > n) {//满足要求，相等
        for (int i = 1; i <= n; ++i) {//输出满足条件的矩阵
            for (int j = 1; j <= n - i + 1; ++j) {
                cout << s[i][j] << " ";//输出一行
            }
            cout << endl;
            if (i != n) {
                cout << setw(i + 1);
            }
        }//for
        ans++;
        cout << endl;
        return;
    }
    for (int i = 0; i < 2 ; ++i) {
        s[1][k] = i;////让第一行第t个字符为i
        for (int j = 2; j <= k; ++j) {//从第二行到第t行的赋值
            s[j][k - j + 1] = s[j - 1][k - j + 1] ^ s[j - 1][k - j + 2];
            //递推子树，2个同号下面都是“+”，2个异号下面都是“-”。
            sum += s[j][k - j + 1];//sum加上新赋值的元素
        }
        Backtrack(k + 1, sum + i);//给第一行第k+1个位置加上i，sum的新值为sum + i
        for (int j = 2; j <= k; ++j) {//回溯时取消上一次的赋值
            sum -= s[j][k - j + 1];//sum减去之前赋值的元素
        }
    }
    return;
}
int main(){
    while (cin >> n) {//n为输入的第一行的个数
        half = n * (n + 1) / 2;//填充符号的个数
        memset(s, 0, sizeof(s));
        if (half % 2 == 1) {
            cout << 0;//总数是奇数直接判0
        }else{
            half /= 2;//half修改为总数的一半
            Backtrack(1, 0);
            cout << "满足条件的三角形的个数是：" << endl << ans;
        }
    }
    return 0;
}


```

## 最大团问题

给定无向图G=(V,E)。如果U∈ V，且对任意u, v ∈ U 有 (u,v) ∈ E，则称U是G的完全子图。G的完全子图U是G的团，当且仅当U不包含在G的更大的完全子图中。G的最大团是指G中所含顶点数最多的团。

Input

输入的第一行为测试样例的个数T ，接下来有T个测试样例。每个测试样例的第一行是 顶点数n 和 边数m （ n ≤ 20，m ≤ 400 ），接下来m行，每行两个整数u和v，表示顶点u和v之间有一条边相连。（ 1 ≤ u < v ≤ n ）。
Output

对应每个测试样例输出两行，第一行格式为"Case #: M"，其中'#'表示第几个测试样例（从1开始计），M为最大团顶点数。
Sample Input

1
5 7
1 2
1 4
1 5
2 3
2 5
3 5
4 5

Sample Output

Case 1: 3

题意分析：

完全子图即是图中任意的两个顶点都有连接，与完全图是一样的。

思路：
    每次都放一个点进入图中，因为是无向图所以其生成的是子集树，只需要把所有点都放进图中尝试一次便可。剪枝部分使用简单的剪枝，即没试过的点+图中的点<当前最优的点即可符合，否则直接跳过该点，尝试下一个点

```c++
#include <stdio.h>
#include <string.h>
int book[25][25],vist[25],que[25];
//que数组表示当前极大团中的点，book邻接矩阵记录边，vist记录访问过的点
int n,m,maxx;
void dfs(int x,int sum){
//对顶点x邻接的边进行搜索，当前极大团的顶点数为sum
    if(x>n){//搜完所有的点，递归出口
        maxx=sum;
        return ;
    }
    int vt=0;//标志位
    for(int j=0;j<sum;j++){//判断x是否与当前极大团的每个顶点邻接
        if(book[x][que[j]] == 0){//都不邻接时置vt为1，跳出循环
            vt=1;
            break;
        }
    }
    if(vt == 0)
    {//相通进入que极大团数组，并且图中顶点+1
        vist[x]=1;//访问数组标记
        que[sum]=x;//加入到极大团中
        dfs(x+1,sum+1);//对顶点x+1进行搜索
    }
//若 未尝试的点 + 极大团的点 < 当前最优的点则剪枝
//其他条件表示有可能有最大点,尝试下一个点，当前极大团不动
    if(sum + n - x > maxx)
        dfs(x + 1,sum);
}
int main(){
    int t,vi=0;
    scanf("%d",&t);
    while(t--){
        scanf("%d %d",&n,&m);
        int x,y;
        memset(vist,0,sizeof(vist));
        memset(book,0,sizeof(book));
        maxx=0;
        for(int i=1;i<=m;i++){
            scanf("%d %d",&x,&y);
            book[x][y]=1;
            book[y][x]=1;
        }
        dfs(1,0);
        vi++;
        printf("Case %d: %d\n",vi,maxx);
    }
    return 0;
}

```

## 货郎问题

```c++
#include<iostream>  
using namespace std;
#define MAX 1000  
int g[100][100], x[100], bestx[100];
int cl = 0, bestl = MAX, n;
//界定函数
double Bound(int t, int cl)
{
	double min1 = 0, min2 = 0, tempSum=0;
	for (int j = t; j <= n; j++)
	{
		if (g[x[t - 1]][x[j]] != -1 && g[x[t - 1]][x[j]] < min1)
		{
			min1 = g[x[t - 1]][x[j]];
		}
		for (int i = 1; i <= n; ++i)
		{
			if (g[x[j]][x[i]] != -1 && g[x[j]][x[i]] < min2)
			{
				min2 = g[x[j]][x[i]];
			}
		}
		tempSum += min2;
	}
 
	return cl + min1 + tempSum;
 
}
 
 
void Traveling(int t)
{
	int j;
	if (t>n) //到达叶子结点  
	{
		
		if (g[x[n]][1] != -1 && (cl + g[x[n]][1]<bestl))
            //推销员到的最后一个城市与出发的城市之间有路径，且当前总距离比当前最优值小  
		{
			for (j = 1; j <= n; j++)
				bestx[j] = x[j];
			bestl = cl + g[x[n]][1];
		}
	}
	else    //没有到达叶子结点  
	{
		for (j = t; j <= n; j++)//搜索扩展结点的左右分支，即所有与当前所在城市临近的城市  
		{
			if (g[x[t - 1]][x[j]] != -1 && Bound(t, cl)<bestl)
			//if (g[x[t - 1]][x[j]] != -1 && (cl + g[x[t - 1]][x[j]]<bestl))
             //如果第t-1个城市与第t个城市之间有路径且可以得到更短的路线  
			{
 
				swap(x[t], x[j]);     //保存要去的第t个城市到x[t]中  
				cl += g[x[t - 1]][x[t]]; //路线长度增加  
				Traveling(t + 1);      //搜索下一个城市  
				cl -= g[x[t - 1]][x[t]];
				swap(x[t], x[j]);
			}
		}
	}
}
int main()
{
	int i, j;
	cout << "请输入一共有几个城市：" << endl;
	cin >> n;
	cout << "请输入城市之间的距离" << endl;
 
	for (i = 1; i <= n; i++)
		for (j = 1; j <= n; j++)
			cin >> g[i][j];
 
	for (i = 1; i <= n; i++)
	{
		x[i] = i;
		bestx[i] = 0;
	}
 
	Traveling(2);
	cout << "城市路线：" << endl;
	for (i = 1; i <= n; i++)
		cout << bestx[i] << ' ';
	cout << bestx[1];
	cout << endl;
	cout << "最短路线长度：" << endl;
	cout << bestl << endl;
	return 0;
}
```

## 圆排列问题

给定n个大小不等的圆c1,c2,…,cn，现要将这n个圆排进一个矩形框中，且要求各圆与矩形框的底边相切。圆排列问题要求从n个圆的所有排列中找出有最小长度的圆排列。例如，当n=3，且所给的3个圆的半径分别为1，1，2时，这3个圆的最小长度的圆排列如图所示。其最小长度为2+4sqrt(2)



![image-20200325133716157](https://gitee.com/yangshucheng2020/blogimage/raw/master/uPic/image-20200325133716157.png)


![image-20200325135817004](https://gitee.com/yangshucheng2020/blogimage/raw/master/uPic/image-20200325135817004.png)

center函数：center计算圆在当前圆排列中的横坐标，由x^2 = sqrt((r1+r2)\^2-(r1-r2)\^2)推导出x = 2 * sqrt(r1 * r2)。为啥要把计算圆心坐标的公式放在一个for循环里面呢？我们很容易会有一个先入为主的思想，那就是后一个圆必然与排在它前一个位置的圆相切，其实排在任意位置的圆与其前或后的任意一个圆都有可能相切的，画个图就很清晰了。只要大小合适，目标圆就有可能与排列中的任意一个圆相切。

![image-20200325135653425](https://gitee.com/yangshucheng2020/blogimage/raw/master/uPic/image-20200325135653425.png)

compute函数：可以想象其中任意的一个圆无限大或无限小，无限大的话那其余的圆就可以统统忽略了。因为已知所有圆的x[]和r[],很容易求出每个圆的左右坐标，通过比较找出最小的左部坐标和最大的右部坐标，一减就是该圆排列的长度，然后把每次不同的排列长度相比较，找到更小的minlen就更新。

![image-20200325133826887](https://gitee.com/yangshucheng2020/blogimage/raw/master/uPic/image-20200325133826887.png)



```c++
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
const int MAXN = 100;
int n;//圆的个数
double minlen=1000000,x[MAXN],r[MAXN];//分别为最小圆排列长度，每个圆心横坐标数组，每个圆半径数组
double bestv[MAXN];//最小圆排列的半径顺序
double center(int t){//得到第t个圆的圆心横坐标
    double tmp = 0;
    for (int i = 1; i < t; ++i) {//计算第t个圆与前面(序号为1~t-1)已排列圆相切时的距离，求最大距离
        double xvalue = x[i] + 2.0 * sqrt(r[i]*r[t]);//计算第t个圆与第i个圆相切时的距离
        if (xvalue > tmp) {//最大的距离就是圆心坐标
            tmp = xvalue;
        }
    }
    return tmp;
}
void compute(){//计算圆排列长度
    double low=0,high=0;
    for (int i = 1; i <= n; ++i) {//寻找最左端与最右端的距离
        if (x[i] - r[i] < low) {
            low = x[i] - r[i];
        }
        if (x[i] + r[i] > high) {
            high = x[i] + r[i];
        }
    }
    if (high - low < minlen) {
        minlen = high - low;
        for (int i = 1; i <= n; ++i) {
            bestv[i] = r[i];
        }
    }
}
void Backtrack(int t){
    if (t > n)
        compute();
    else{
        for (int i = t; i <= n; ++i) {
//确保全排列：一开始按顺序的时候没交换，第一次排列后，回溯时i与t不同
            swap(r[t], r[i]);
            double centerx = center(t);//计算第t个圆的横坐标
            if (centerx + r[1] + r[t] < minlen) {//剪枝
                x[t] = centerx;//确定了加入第t个圆的圆排列长度
                Backtrack(t + 1);//搜索下一个圆
            }
            swap(r[t], r[i]);//回溯，将前面全排列结束后复原，再接着从更前一个元素开始排列
        }
    }
}
int main()
{
    cout << "圆的个数 n：";
    cin >> n;
    cout << "每个圆的半径分别为：";
    for (int i = 1; i <= n; ++i) {
        cin >> r[i];
    }
    Backtrack(1);
    cout << "最小圆排列长度为：" << minlen <<endl;
    cout << "最优圆排列的顺序对应的半径分别为：";
    for (int i = 1; i <= n; ++i) {
        cout << bestv[i] << " ";
    }
    return 0;
}

```

## 连续邮资问题

假设国家发行了k种不同面值的邮票，并且规定每张信封上最多只允许贴h张邮票。连续邮资问题要求对于给定的k和h的值，给出邮票面值的最佳设计，在1张信封上可贴出从邮资1开始，增量为1的最大连续邮资区间。例如，当k=5和h=4时，面值为(1,3,11,15,32)的5种邮票可以贴出邮资的最大连续邮资区间是1到70。（UVA165）

![image-20200326170059426](https://gitee.com/yangshucheng2020/blogimage/raw/master/uPic/image-20200326170059426.png)

思路概括：

* 用stampval来保存各个面值，用maxval来保存当前所有面值能组成的最大连续面值。

* stampval[0] 一定等于1，因为1是最小的正整数。相应的，maxval[0]=1*h。接下去就是确定第二个，第三个......第k个邮票的面值了。对于stampval[i+1]，它的取值范围stampval[i]+1~maxval[i]+1。 

* stampval[i]+1是因为这一次取的面值肯定要比上一次的面值大，而这次取的面值的上限是上次能达到的最大连续面值+1， 是因为如果比这个更大的话， 那么就会出现断层， 即无法组成上次最大面值+1这个数了。 

* 举个例子， 假设可以贴3张邮票，有3种面值，前面2种面值已经确定为1,2， 能达到的最大连续面值为6， 那么接下去第3种面值的取值范围为3～7。如果取得比7更大的话会怎样呢？ 动手算下就知道了，假设取8的话， 那么面值为1,2,8，将无法组合出7。直接递归回溯所有情况， 便可知道最大连续值了。


![image-20200326170152534](https://gitee.com/yangshucheng2020/blogimage/raw/master/uPic/image-20200326170152534.png)

![image-20200326170523901](https://gitee.com/yangshucheng2020/blogimage/raw/master/uPic/image-20200326170523901.png)

### 回溯法

变量说明：
* ans为最终方案的面值组合,maxStampVal是最终方案的最大面值
* stampVal\[1\~n\]来保存各个邮票面值，maxVal\[1\~n\]来保存当前所有面值能组成的最大连续面值
* stampVal[1]一定是等于1的。因为如果没有1的话，很多数字都不能凑成
* maxVal[1] = 1*h ,h为允许贴邮票的数量
* 对于stampVal[i+1],它的取值范围是stampVal[i]+1 ~maxVal[i]+1.
* occur是一个全局数组,调用递归时先初始化为0,然后用它来记录出现过的面值之和，最后只需要从occur数组的下标1开始枚举，直到不是true值时就是能达到的最大连续面值。

回溯过程：（进行到第cur种面额邮票时）

* cur > n 时：算法搜索到叶结点，得到新的邮票面值设计方案x[1:n]。如果该方案能够给出的最大连续邮资区间大于当前已找到的最大连续邮资区间maxvalue，则更新当前最优值maxvalue和相应的最优解ans。
* cur <= n 时：当前扩展结点Z是解空间的内部节点。在该节点处，x[1:cur-1]能给出的最大连续邮资区间为r-1因此，在结点Z处，x[i]的可取值范围是[x[cur-1] + 1 : r + 1]，从而，结点Z有r - x[cur-1]个儿子节点。算法对当前扩展结点Z的每个儿子结点，以深度优先的方式递归地对相应子树进行搜索

dfs(int mcur, int n, int sum)说明：

* 计算给定面额种类下，最大数量不超过m时，当前数量为mcur时能够达到的最大连续面值sum
* 当前用了mcur张邮票，在当前邮票种类数 n下，面额之和是sum
* mcur >= m 时：达到了单种邮票的最大张数，记录当前总的面额sum
* mcur < m 时：
  * 记录记录当前总的面额sum
  * 将其他种类的邮票各加一张进行深度优先搜索


```c++
#include<cstring>
#include<cstdio>
#include<iostream>
const int MAXN = 200;
using namespace std;
int m, n;
int ans[MAXN], maxStampVal, stampVal[MAXN], maxVal[MAXN];//从下标1开始赋值
bool occur[MAXN];
void dfs(int mcur, int n, int sum){
    // mcur当前用了几张票， n当前面额种类数， sum面额之和
    // 计算给定面额和数量能够达到的最大连续面值
    if(mcur >= m){//达到单种邮票的最大张数
        occur[sum] = true;
        return;
    }
    occur[sum] = true;//sum面额可以达到
    for(int i = 1; i <= n; ++i){//一张一张地增加
        dfs(mcur + 1, n, sum + stampVal[i]);//面额种类加1，面额之和需加上当前邮票面额
    }
}
void search(int cur){//在 第cur种 邮票下进行搜索
    if(cur > n){//已经达到最大邮票种类数，cur = n + 1
        if(maxVal[cur - 1] > maxStampVal){//如果第n张邮票的最大连续面额为当前最大
            maxStampVal = maxVal[cur - 1];//更新最大连续面额
            memcpy(ans, stampVal, sizeof(stampVal));//将邮票面额组合赋值给ans
        }
        return ;
    }
    for(int i = stampVal[cur - 1] + 1; i <= maxVal[cur - 1] + 1; ++i){
        //对第cur种面额的可取值范围进行最大连续面额的搜索
        memset(occur, 0, sizeof(occur));//每一次新的面额下都要初始化出现数组
        stampVal[cur] = i;//第cur个邮票面值为 i
        dfs(0, cur, 0);//进行张数的搜索
        int num=0, j=1;
        while(occur[j++]) ++num;//寻找第一个没有连续访问的面额num
        maxVal[cur] = num;//第cur种邮票的最大面额为num
        search(cur+1);//对第cur+1种邮票进行搜索
    }
}
int main(){
    //n面额数，m每种邮票可以使用的数量
    while(scanf("%d %d", &n, &m)!=EOF){
        stampVal[1] = 1;
        maxVal[1] = m;
        maxStampVal = -1;
        search(2);
        for(int i = 1; i <= n; ++i)
            printf("%3d", ans[i]);
        printf(" ->%3d\n", maxStampVal);
    }
    return 0;
}
```

### 回溯法+动态规划法

设不超过m张面值为x[1:i]的邮票贴出邮资j所需的最少邮票数为y[j]。通过y[j]可以很快推出r的值。事实上，y[j]可以通过递推在O(n)时间内解决：

![image-20200326145529471](https://gitee.com/yangshucheng2020/blogimage/raw/master/uPic/image-20200326145529471.png)

类似于0-1背包问题：

* y[j]表示贴上去的邮资j时的最小耗费邮票数，类似背包问题中的w[j]表示价值为j时的最小重量
* y[j+x[i-1] * k] = min(y[j+x[i-1] * k],y[j] + k)，类似背包问题中的w[j] =  min(w[j-val[i-1]],w[j])
* 初始化y[j]时，意味着在只有m张面额为1的邮票下，贴上去的邮资为j时的最小耗费邮票数，即y[j] = j
* 最大连续邮资为r，maxVal[cur] = r

```c++
for (int j=0; j<= x[i-2]*(m-1);j++)
        if (y[j]<m)
          for (int k=1;k<=m-y[j];k++)
            if (y[j]+k<y[j+x[i-1]*k]) y[j+x[i-1]*k]=y[j]+k;
      while (y[r]<maxint) r++;
```

```c++
#include<cstring>
#include<cstdio>
#include<cstdlib>
#include<iostream>
#define INF 2147483647
const int MAXN = 2000;
using namespace std;
int m, n;
int ans[MAXN], maxStampVal, stampVal[MAXN], maxVal[MAXN], y[MAXN];
bool occur[MAXN];
void search(int cur){//搜索前cur种邮票的最大连续邮资
    if(cur > n){
        if(maxVal[cur-1] > maxStampVal){
            maxStampVal = maxVal[cur-1];
            memcpy(ans, stampVal, sizeof(stampVal));
        }
        return ;
    }
    int tmp[MAXN];//tmp存储当前y数组,为接下来回溯后返回用
    memcpy(tmp, y, sizeof(y));
    for(int i = stampVal[cur - 1] + 1; i <= maxVal[cur - 1] + 1; ++i){
        //对第cur种面额的可取值范围进行最大连续面额的搜索
        stampVal[cur] = i;//第cur个邮票面值为 i
        // 关键步骤，利用了动态规划的思想
        //设不超过m张面值为x[1:i]的邮票贴出邮资j所需的最少邮票数为y[j]
        //y贴出的邮资为0~（第cur-1种邮票）*m
        for(int j = 0; j < stampVal[cur - 1] * m; ++j){
            if(y[j] < m){//不超过m张的时候
            for(int num = 1; num <= m - y[j]; ++num){
            //num为可以贴上面额为i的邮票的数量
//如果最少邮票数y[j]添加num张邮票时的张数（y[j] + num）
//小于 y[j]再添加num张邮票时的邮资 的张数（y[j + i * num]）时，
//说明邮资为j + i * num时耗费的张数应该是更小的y[j] + num
                if(y[j] + num < y[j + i * num] && (j + i * num < MAXN))
                    y[j + i * num] = y[j] + num;
            }
            }
        }
        int r = maxVal[cur - 1];//最大连续邮资为r
        while(y[r + 1] < INF) r++;//当y[r+1]有进行动态规划得到的值时，说明最大连续邮资可以到r+1
        maxVal[cur] = r;//当前的最大连续邮资为r
        search(cur + 1);//搜索cur+1时的情况
        memcpy(y, tmp, sizeof(tmp));//回溯y
    }
}
int main(){
    //n邮票面额种类数,m单种邮票最大张数
    while(scanf("%d %d", &n, &m)!=EOF){
        stampVal[1] = 1;//第一张邮票必须是1
        maxVal[1] = m;//用m张面值为1的邮票组成的最大连续面额为m
        int i=0;
        for(i = 0; i <= m; ++i)
            y[i] = i;//只有一张面值为1的邮票时，y[i]=i
        while(i < MAXN) y[i++] = INF;//其他y[i+1~MAXN]必须最大,方便之后选更小的
        maxStampVal = -1;
        search(2);
        for(i = 1; i <= n; ++i)
            printf("%3d", ans[i]);
        printf(" ->%3d\n", maxStampVal);
    }
    return 0;
}
```

## 0 1背包回溯法

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXN = 200;
int C,n;
int x[MAXN],bestK[MAXN];//存储节点序号
int cw;//cw存储当前已放入背包的重量
double bestv=-1,curv=0;//bestv存储全局最大价值，curv存储当前的价值
struct Knap{
    int num;//物品的序号
    double weight;//必须是double才可以进行除法的比大小
    double value;//物品的价值
};
Knap K[MAXN];
bool Compare(Knap a,Knap b){//单位重量价值高的排在前面
    return a.value/a.weight > b.value/b.weight;
}
double remainMaxValue(int k){//求出不选择第k性价比物品时，有可能的剩余最大价值
    int rw = C - cw;//背包剩余的质量
    double b = curv;//当前已有的价值
    while (k + 1 <= n && K[k + 1].weight <= rw) {//如果还有物品，并且这个物品小于剩余的质量，则放入
        b += K[k + 1].value;//更新价值
        rw -= K[k + 1].weight;//更新剩余容量
        k = k + 1;//对下一个物品进行判断
    }
    if (k + 1 <= n) {//剩余的容量选择部分物品
        b = b + K[k+1].value / K[k+1].weight * rw;
    }
    return b;
}
void Backtrack(int k){//对第k性价比的物品进行搜索
    if (k > n) {//所有的物品都循环完了
        if (curv > bestv) {
            bestv = curv;//记录最大值
            for (int i = 1; i <= n; ++i) {
                bestK[i] = x[i];//更新放入的物品序号
            }
        }
    }
    else{
        if (cw + K[k].weight <= C) {//如果当前这个序号的物品不超重(小于等于)，试着放入
            x[K[k].num] = 1 ;//把当前序号标记
            cw += K[k].weight;//更新当前重量
            curv +=  K[k].value;//更新当前价值
            Backtrack(k + 1);//进入下一步
            cw -= K[k].weight;//回退重量
            curv -= K[k].value;//回退价值
        }
        if(remainMaxValue(k) > bestv){
            //如果不选择第k性价比的物品时剩余最大价值可以超过当前最大价值，有进行下一步的必要
            x[K[k].num] = 0;//不选择k
            Backtrack(k + 1);//下一步
       }
    }
    
}
int main(){
    cout << "输入背包最大容量C，物品种类数目n"<< endl;
    cin >> C >> n;
    cout << "输入n件物品的重量与价值" << endl;
    for (int i = 1; i <= n; ++i) {
        K[i].num = i;
        cin >> K[i].weight >> K[i].value;
    }
    sort(K + 1, K + n + 1,Compare);//按照性价比进行排序
    Backtrack(1);//子集树回溯
    cout << "最大价值为" << bestv << endl;
    cout << "放入背包的物品序号" << endl;
    for (int i = 1; i <= n; ++i) {
        if (bestK[i] != 0) {
            cout << i << " ";
        }
    }
    return 0;
}
```

## 电路板排列问题

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int MAXN = 100;
int n,m;//电路板个数：n,连接块个数：m
int x[MAXN];//当前电路板排序
int bestx[MAXN];//最优电路板排序
int b[9][6];//8个电路板，5个连接块，b[i][j]表示电路板i在连接块j当中
int now[MAXN];//now[k]表示当前连接块k中已扫描到的电路板个数
int total[MAXN];//total[k]表示连接块k中所有的电路板个数
int bestd = 9999999;//初始最优度数设置大一些
//搜索排列树
//第i个电路板，当前排列密度为cd
void Backtrack(int i,int cd){
    if (i == n) {//当到达叶结点
        bestd = cd;//算法仅完成比当前解更优的解，所以cd肯定优于bestd
        memcpy(bestx, x, sizeof(x));//拷贝最优解向量
    }
    else{
        for (int j = i; j <= n; ++j) {//选择第x[j]为下一块电路板
            int id = 0;//计算增加了电路板x[j]后的连线密度：插槽j和插槽j+1的连线密度
            for (int k = 1; k <= m; ++k) {
                now[k] += b[x[j]][k]; 
                //now[k]表示连接块k中在排列x[1:j]时所包含的电路板个数
                if (now[k] > 0 && now[k] != total[k] ) {//满足此条件
                    id++;//连线密度增加
                }
            }
            if (id < cd) {//更新ld，选择更大的连线密度
                id = cd;
            }
            if (id < bestd) {//如果当前连线密度小于最优值，才可能产生最优值，搜索子树
                swap(x[i], x[j]);
                Backtrack(i + 1, id);//搜索下一个结点
                swap(x[i], x[j]);
            }
            //恢复状态，为返回上一层做准备
            for (int k = 1; k <= m; ++k) {
                now[k] -= b[x[j]][k];
            }
        }
    }
}
void Arrangement(int b1[9][6],int n,int m){
    for (int i = 0; i <= n; ++i) {
        for (int j = 0; j <= m; ++j) {
            b[i][j] = b1[i][j];
        }
    }
    memset(now, 0, sizeof(now));
    memset(total, 0, sizeof(total));
    //初始化x为单位排列并计算total
    for (int i = 1; i <= n; ++i) {
        x[i] = i;
        for(int j = 1;j <= m;++j){
            total[j] += b[i][j];
        }
    }
    Backtrack(1, 0);
}
int main()
{
    n = 8;
    m = 5;
    int b1[9][6] = {
        {0, 0, 0, 0, 0, 0},
        {0, 0, 0, 1, 0, 0},
        {0, 0, 1, 0, 0, 0},
        {0, 0, 1, 1, 1, 0},
        {0, 1, 0, 0, 0, 0},
        {0, 1, 0, 0, 0, 0},
        {0, 1, 0, 0, 1, 0},
        {0, 0, 0, 0, 0, 1},
        {0, 0, 0, 0, 0, 1}
    };
    Arrangement(b1, n, m);
    printf("电路板个数：%d\n", n);
    printf("连接块个数：%d\n", m);
    printf("连接块情况：\n");
    printf("N1={4,5,6},N2={2,3},N3={1,3},N4={3,6},N5={7,8}\n");
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            printf("%d ",b[i][j]);
        }
        printf("\n");
    }
    printf("最优密度为：%d\n", bestd);
    printf("最优排列为：\n");
    for (int i = 1; i <= n; ++i) {
        printf("%d ",bestx[i]);
    }
    return 0;
}
```

## 数独问题

编写一个程序，通过已填充的空格来解决数独问题。

一个数独的解法需遵循如下规则：

    数字 1-9 在每一行只能出现一次。
    数字 1-9 在每一列只能出现一次。
    数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

空白格用 '.' 表示。

![数独图片](https://gitee.com/yangshucheng2020/blogimage/raw/master/uPic/250px-Sudoku-by-L2G-20050714.svg-20200412205810696.png)

一个数独

![填充好的数独](https://gitee.com/yangshucheng2020/blogimage/raw/master/uPic/250px-Sudoku-by-L2G-20050714_solution.svg.png)

填充之后

```cpp
class Solution {
public:
    void solveSudoku(vector<vector<char>>& board) {
        backtrack(board,0,0);
    }

    bool backtrack(vector<vector<char>>& board, int row, int col){
        if(col == 9)
            return backtrack(board,row+1,0);

        if(row == 9)
            return true;

        for(int i = row; i < 9; i++){
            for(int j = col; j < 9; j++){
                if(board[i][j] != '.'){
                    return backtrack(board, i, j + 1);
                }
                for(char ch = '1'; ch <= '9'; ch++){
                    if(!isValid(board, i, j, ch))
                        continue;
                    board[i][j] = ch;
                    if(backtrack(board, i, j + 1))
                        return true;
                    board[i][j] = '.';
                }
                return false;

            }
        }
        return false;
    }

    bool isValid(vector<vector<char>>& board, int row, int col, char ch){
        for(int i = 0; i < 9; i++){
            if(board[row][i] == ch) return false;
            if(board[i][col] == ch) return false;
            if(board[(row/3)*3 + i/3][(col/3)*3 + i%3] == ch) return false;
        }
        return true;
    }
};
```

## 岛屿问题

给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。

示例 1:

输入:
11110
11010
11000
00000

输出: 1

```cpp
class Solution {
private:
    int rows,cols;
     int d[4][2]={{0,1},{0,-1},{1,0},{-1,0}};
    void dfs(vector<vector<char>> &grid,int x,int y)
    {
        if(x<0||x==rows||y<0||y==cols||grid[x][y]=='0') return;
        grid[x][y]='0';
        for(int i = 0 ;i<4;i++)
        {
            int nx = x + d[i][0];
            int ny = y + d[i][1];
            dfs(grid,nx,ny);
        }
        return;
    }
public:

    int numIslands(vector<vector<char>>& grid) {
        int ans=0;
        rows = grid.size();
        if(rows == 0) return 0;
        cols = grid[0].size();
        for(int i=0;i<rows;i++)
        {
            for(int j=0;j<cols;j++)
            {
                if(grid[i][j]=='1')
                {
                    ans++;
                    dfs(grid,i,j);
                } 
            }
        }
        return ans;
    }

};
```

